---
layout: post
title: Version 1.0
description: Initial Version
type: game
courses: { versions: {week: 0} }
---
<head>
    <meta name="layout" content="post">
    <meta name="title" content="Version 1.0">
    <meta name="description" content="Initial Version">
    <meta name="type" content="game">
    <meta name="courses" content="{ versions: {week: 0} }">
</head>

<html>
    <div class="gameWrapper">
        <div class="frameWrapper">
            <div id="topMenu">
                <button class="topMenuBtn" id="mainMenuBtn">Main Menu</button>
                <button class="topMenuBtn" id="inventoryBtn">Inventory</button>
                <button class="topMenuBtn" id="mapBtn">Map</button>
            </div>
            <canvas id="gameFrame" width="728" height="800">
                <img id="labBackground" src="../../../images/mortensenlabbackground.jpg"/>
            </canvas>
            <canvas id="mortFrame">
                <img id="mort" src="../../../images/mortspritesheet.jpg"/>
            </canvas>
        </div>
    </div>
</html>

<script>
window.addEventListener('load', function () {
        // const bg = document.getElementById("labBackground");
        // document.getElementById("gameFrame").getContext('2d').drawImage(bg, 0, 0, 728, 800);

        const canvas = document.getElementById('mortFrame');
        const ctx = canvas.getContext("2d")
        const sprite = document.getElementById("mort")
        const SPRITE_WIDTH = 16;  // matches sprite pixel width
        const SPRITE_HEIGHT = 24; // matches sprite pixel height
        const SCALE_FACTOR = 1.5;  // control size of sprite on canvas
        const FRAME_LIMIT = 9;  // number of frames per row, this code assume each row is same
        let SPRITE_SPEED = 100 // delay between each frame (miliseconds)
        canvas.width = SPRITE_WIDTH * SCALE_FACTOR;
        canvas.height = SPRITE_HEIGHT * SCALE_FACTOR;
        canvas.x = 100
        class Mort {
            constructor() {
                this.image = document.getElementById("mort");
                this.spriteWidth = SPRITE_WIDTH;
                this.spriteHeight = SPRITE_HEIGHT;
                this.width = this.spriteWidth;
                this.height = this.spriteHeight;
                this.x = 0;
                this.y = 0;
                this.scale = SCALE_FACTOR;
                this.minFrame = 0;
                this.maxFrame = FRAME_LIMIT-1;
                this.frameX = 0;
                this.frameY = 0;
            }

            // draw mort object
            draw(context) {
                context.drawImage(
                    this.image,
                    this.frameX * this.spriteWidth,
                    this.frameY * this.spriteHeight,
                    this.spriteWidth,
                    this.spriteHeight,
                    this.x,
                    this.y,
                    this.width * this.scale,
                    this.height * this.scale
                );
            }

            // update frameX of object
            update() {
                if (this.frameX < this.maxFrame) {
                    this.frameX++;
                } else {
                    this.frameX = 0;
                }
            }
        }

        // mort object
        const mort = new Mort();

        // update frameY of mort object, action from idle, bark, walk radio control
        function changeAnimation(input) {
            switch (input) {
                    case 'up':
                        mort.frameY = 0;
                        break;
                    case 'left':
                        mort.frameY = 1;
                        break;
                    case 'down':
                        mort.frameY = 2;
                        break;
                    case 'right':
                        mort.frameY = 3;
                        break;
                    default:
                        break;
                }
        }

        const validKeys = {
            "w": "up",
            "a": "left",
            "s": "down",
            "d": "right",
        }
        document.addEventListener("keypress", (event) => {
            if (!Object.keys(validKeys).includes(event.key)) {
                return;
            }
            changeAnimation(validKeys[event.key])   
        })

        // Animation recursive control function
        function animate(timeStamp) {
            // Clears the canvas to remove the previous frame.
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draws the current frame of the sprite.
            mort.draw(ctx);
            // Updates the `frameX` property to prepare for the next frame in the sprite sheet.
            mort.update();
            SPRITE_SPEED = 100
            // Uses `requestAnimationFrame` to synchronize the animation loop with the display's refresh rate,
            // ensuring smooth visuals.
            setTimeout(() => {requestAnimationFrame(animate);}, SPRITE_SPEED);
            
        }

        // run 1st animate
        animate();
    });

</script>

<style>
    .frameWrapper {
        margin: auto;
        width: 728px;
        border: 2px solid #00ADB5;
        text-align: center;
        margin-top: 1%;
    }
    
    .topMenuBtn {
        border: 0px;
        background-color: #393E46;
        padding: 15px;
    }

    .topMenuBtn:hover {
        border: 0px;
        background-color: #393e469f;
        padding: 15px;
    }

    #topMenu {
        display: flex;
        gap: 10px;
        background-color: #393e465c;
        justify-content: space-evenly;
        align-content: center;
        flex-direction: row;
        align-items: stretch;
    }

    #gameFrame {
        background-color: #fff;
        border-top: 2px solid #00ADB5;
    }
</style>